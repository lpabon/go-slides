Securing your gRPC Application
Authentication, Authorization, and RBAC in gRPC

July 18 2019

Luis Pabón
MTS, Portworx
luis@portworx.com
https://github.com/lpabon/go-slides
Twitter: `@_lpabon_`

* About me

Luis Pabón

- CNCF Storage Technical Lead
- Kubernetes SIG-Storage Community Member
- Container Storage Interface (CSI) Community Member

Previously at CoreOS and Red Hat Storage

.image nyc-meetup-july-18-2019/me.jpg _ 400

* History

Requirements:

- We wanted to create an SDK to make it easy for developers to integrate Portworx technology with their control plane
- We wanted to make sure that only certain users had the ability to use certain resources

We added gRPC authentication, authorization with RBAC to our [[https://libopenstorage.github.io][OpenStorage SDK]]

* Security Models

*Authentication*:

- Who are you?
- How can I trust that you are who you say you are?
- What other information is there about you?

*Authorization*:

- Are you allowed to do what you are asking?
- Are you allowed to access that information?

* Authentication

* Hello, my name

.image nyc-meetup-july-18-2019/voice-is-password.jpg _ 800

* Security Architecture

- Discuss how to store passwords security
- Manage passwords
- ...

* No!

DO NOT DO PASSWORD MANAGEMENT!

.image nyc-meetup-july-18-2019/no.gif _ 400

* Authentication in gRPC

This talk will be basing authentication on the following models:

- Using JSON Web Token as stated in the [[https://tools.ietf.org/html/draft-ietf-oauth-json-web-token-25][IETF draft]] to identify a user
- gRPC applications should only verify the token from a trusted issuer

* JWT

JWT has the following components:

  [ header . claims . signature ]

Example:

  eyJhb[...omitted for brevity...]HgQ

*Header*: Token and signature types in clean text
*Claims*: JSON formatted metadata about the user in clear text
*Signature*: Signature created using crypto hash

_Important_: Tokens are created by other entities and the gRPC applications only need to *verify* the token

* Generating a token (Python)

Python

    import jwt
    import datetime
    import hashlib

    secret = 'My secret'
    claims = {}
    claims['iss'] = tokenIssuer
    claims['iat'] = datetime.datetime.utcnow()
    claims['exp'] = datetime.datetime.utcnow() \
        + datetime.timedelta(minutes=10)
    print jwt.encode(claims, secret, algorithm='HS256')

* Generating a token (Golang)

Golang pseudocode

  mapclaims := jwt.MapClaims{
    "sub":   claimsSubject,
    "iss":   tokenIssuer
    "email": claimsEmail,
    "name":  claimsName,
    "role":  claimsRole,
    "iat":   time.Now().Unix(),
    "exp":   time.Now().Add(expDuration).Unix(),
  }
  token := jwt.NewWithClaims(signature.Type, mapclaims)
  signedtoken, err := token.SignedString(signature.Key)

See [[https://github.com/libopenstorage/openstorage-sdk-auth/blob/master/pkg/auth/auth.go#L60][github.com/libopenstorage/openstorage-sdk-auth]]

* Client Token

Clients insert the the token in the gRPC metadata

Example (Golang):

  import "google.golang.org/grpc/metadata"

  md := metadata.New(map[string]string{
      "authorization": "bearer" + token,
    })
  ctx = metadata.NewOutgoingContext(context.Background(), md)
  _, err := YourGrpcApi(ctx, ...)

See: [[https://github.com/libopenstorage/libopenstorage.github.io/blob/7727f6a7755a4a8c376adf258f760b0801c2eeb9/examples/golang/main.go#L33-L62][Example]]

Example (Python):

  md = []
  md.append(("authorization", "bearer "+token))

  # Now add metadata to the call
  stub = api_pb2_grpc.YourAPIStub(channel)
  response = stub.YourApi(api_pb2.YourApiRequest(), metadata=md)

* gRPC Server Architecture

Use gRPC interceptors to get authentication and authorization support

  +---------------+
  |  Interceptor  |  <----- Client
  +---------------+
          |
  +---------------+
  |   gRPC Server |
  |    Handlers   |
  +---------------+


* A simple interceptor

	func SimpleIntercepter(
		ctx context.Context,
		req interface{},
		info *grpc.UnaryServerInfo,
		handler grpc.UnaryHandler,
	) (interface{}, error) {

		// ctx has metadata about the call

		// You can add information in the ctx for other interceptors to use
		ctx = context.WithValue(ctx, "somekey", somedata)

		// info has the API name
		logger.Printf("In SimpleInterceptor: Method=%s", info.FullMethod)

		// Call the next handler
		return handler(ctx, req)
	}

Interceptors are initialized in the gRPC server configuration.

* Authentication registration

Setup the interceptors in order in _ServerOption_

	import (
	  grpc_middleware "github.com/grpc-ecosystem/go-grpc-middleware"
	  grpc_auth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	)

	opts := make([]grpc.ServerOption, 0)
	opts = append(opts, grpc.UnaryInterceptor(
		grpc_middleware.ChainUnaryServer(
			simpleinterceptor,
			grpc_auth.UnaryServerInterceptor(auth),
		)))
	grpcServer := grpc.NewServer(opts...)
	...

See [[https://github.com/libopenstorage/openstorage/blob/3d7c200148a18d9586811f0250b1b90f7466e69b/api/server/sdk/server.go#L422-L451][Example]]

* Authentication interceptor

	import (
	  grpc_auth "github.com/grpc-ecosystem/go-grpc-middleware/auth"
	  "google.golang.org/grpc/codes"
	  "google.golang.org/grpc/status"
	)
	...
	func  auth(ctx context.Context) (context.Context, error) {
		// grpc_auth.AuthFromMD will extract the token from the key
		// "authorization" and return the token after removing the "bearer " prefix
		token, err := grpc_auth.AuthFromMD(ctx, "bearer")
		if err != nil {
			return nil, err
		}
		if err := verify(token); err != nil {
			return nil, status.Errorf(codes.PermissionDenied, err.Error())
		}
		return ctx, nil
	}

See [[https://github.com/libopenstorage/openstorage/blob/3d7c200148a18d9586811f0250b1b90f7466e69b/api/server/sdk/server_interceptors.go#L55-L88][Example]]



